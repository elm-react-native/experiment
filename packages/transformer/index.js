const defaultTransformer = require("metro-transform-worker");
const fs = require("fs");
const shell = require("shelljs");
const path = require("path");
const readline = require("readline");
const util = require("util");
const patch = require("./patcher");

const p = (...ps) => path.join(__dirname, ...ps);

const getElmJson = async (projectRoot) => {
  for (f of [
    path.resolve(path.join(projectRoot, "elm.json")),
    path.resolve(path.join(projectRoot, "../elm.json")),
    path.resolve(path.join(projectRoot, "../../elm.json")),
  ]) {
    if (await util.promisify(fs.exists)(f)) {
      return {
        path: path.dirname(f),
        data: JSON.parse(
          await util.promisify(fs.readFile)(f, { encoding: "utf-8" })
        ),
      };
    }
  }
};

const moduleNameComment = (elmModuleName) => {
  return {
    moduleName: elmModuleName,
    time: new Date(),
  };
};

const readFirstLine = async (filename) => {
  const fileStream = fs.createReadStream(filename);
  try {
    for await (const line of readline.createInterface(fileStream)) {
      return line;
    }
    return "";
  } finally {
    fileStream.destroy();
  }
};

const readElmjsModuleName = async (filename) => {
  try {
    return JSON.parse((await readFirstLine(filename)).replace("//", "").trim())
      .moduleName;
  } catch (e) {
    // this means the elm.js is not generate by resolver
    return;
  }
};

const getElmModulePath = async (projectRoot, filename) => {
  const elmjson = await getElmJson(projectRoot);
  // console.log("elmjson", elmjson);
  if (!elmjson) return;

  const moduleName = await readElmjsModuleName(filename);
  // console.log("moduleName", moduleName);
  if (!moduleName) return;

  const modulePathBase = moduleName.replace(/\./g, path.sep) + ".elm";
  const sourceDirs = elmjson.data["source-directories"];
  for (src of sourceDirs) {
    const modulePath = path.join(elmjson.path, src, modulePathBase);
    // console.log("checking", modulePath);
    if (await util.promisify(fs.exists)(modulePath)) {
      return modulePath;
    }
  }
  throw new Error(
    `Module '${moduleName}' not found. Tried source-directories: ${sourceDirs}`
  );
};

const executeElmMake = async (target, output) => {
  const cmd = `elm make ${target} --output=${output} --report=json`;
  console.log(`Executing ${cmd}`);
  await util.promisify(shell.exec)(cmd);
};

module.exports = {
  transform: async (config, projectRoot, filename, data, options) => {
    if (path.basename(filename) === "elm.js") {
      // console.log("transform", filename);

      const elmModulePath = await getElmModulePath(projectRoot, filename);

      if (elmModulePath) {
        // this means elm.js was generated by resolver with target module info at first line
        // and we need run elm make to generate actual code before transform
        await executeElmMake(elmModulePath, filename);
      } else {
        // this means elm.js was updated by elm compiler after first compile
      }

      console.log(`Pathing ${filename}...`);
      const patchedData = await patch(filename);

      return await defaultTransformer.transform(
        config,
        projectRoot,
        filename,
        Buffer.from(patchedData),
        options
      );
    }

    return defaultTransformer.transform(
      config,
      projectRoot,
      filename,
      data,
      options
    );
  },

  getCacheKey: (config) => {
    const res = defaultTransformer.getCacheKey(config);
    return `elm-react-natvie${res}`;
  },
};
